<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link Explorer | ArcHive - Verify Content Integrity</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="cache-bust" content="v2024-11-02-standalone">
    
    <!-- üéì BLAKE2B LIBRARY - Self-contained browser version (RFC 7693 compliant) -->
    <script src="static/js/blakejs-browser.js?v=1763761129"></script>

    
    <script id="md5-library">
!function(n){"use strict";function d(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}function f(n,t,r,e,o,u){return d((u=d(d(t,n),d(e,u)))<<o|u>>>32-o,r)}function l(n,t,r,e,o,u,c){return f(t&r|~t&e,n,t,o,u,c)}function g(n,t,r,e,o,u,c){return f(t&e|r&~e,n,t,o,u,c)}function v(n,t,r,e,o,u,c){return f(t^r^e,n,t,o,u,c)}function m(n,t,r,e,o,u,c){return f(r^(t|~e),n,t,o,u,c)}function c(n,t){var r,e,o,u;n[t>>5]|=128<<t%32,n[14+(t+64>>>9<<4)]=t;for(var c=1732584193,f=-271733879,i=-1732584194,a=271733878,h=0;h<n.length;h+=16)c=l(r=c,e=f,o=i,u=a,n[h],7,-680876936),a=l(a,c,f,i,n[h+1],12,-389564586),i=l(i,a,c,f,n[h+2],17,606105819),f=l(f,i,a,c,n[h+3],22,-1044525330),c=l(c,f,i,a,n[h+4],7,-176418897),a=l(a,c,f,i,n[h+5],12,1200080426),i=l(i,a,c,f,n[h+6],17,-1473231341),f=l(f,i,a,c,n[h+7],22,-45705983),c=l(c,f,i,a,n[h+8],7,1770035416),a=l(a,c,f,i,n[h+9],12,-1958414417),i=l(i,a,c,f,n[h+10],17,-42063),f=l(f,i,a,c,n[h+11],22,-1990404162),c=l(c,f,i,a,n[h+12],7,1804603682),a=l(a,c,f,i,n[h+13],12,-40341101),i=l(i,a,c,f,n[h+14],17,-1502002290),c=g(c,f=l(f,i,a,c,n[h+15],22,1236535329),i,a,n[h+1],5,-165796510),a=g(a,c,f,i,n[h+6],9,-1069501632),i=g(i,a,c,f,n[h+11],14,643717713),f=g(f,i,a,c,n[h],20,-373897302),c=g(c,f,i,a,n[h+5],5,-701558691),a=g(a,c,f,i,n[h+10],9,38016083),i=g(i,a,c,f,n[h+15],14,-660478335),f=g(f,i,a,c,n[h+4],20,-405537848),c=g(c,f,i,a,n[h+9],5,568446438),a=g(a,c,f,i,n[h+14],9,-1019803690),i=g(i,a,c,f,n[h+3],14,-187363961),f=g(f,i,a,c,n[h+8],20,1163531501),c=g(c,f,i,a,n[h+13],5,-1444681467),a=g(a,c,f,i,n[h+2],9,-51403784),i=g(i,a,c,f,n[h+7],14,1735328473),c=v(c,f=g(f,i,a,c,n[h+12],20,-1926607734),i,a,n[h+5],4,-378558),a=v(a,c,f,i,n[h+8],11,-2022574463),i=v(i,a,c,f,n[h+11],16,1839030562),f=v(f,i,a,c,n[h+14],23,-35309556),c=v(c,f,i,a,n[h+1],4,-1530992060),a=v(a,c,f,i,n[h+4],11,1272893353),i=v(i,a,c,f,n[h+7],16,-155497632),f=v(f,i,a,c,n[h+10],23,-1094730640),c=v(c,f,i,a,n[h+13],4,681279174),a=v(a,c,f,i,n[h],11,-358537222),i=v(i,a,c,f,n[h+3],16,-722521979),f=v(f,i,a,c,n[h+6],23,76029189),c=v(c,f,i,a,n[h+9],4,-640364487),a=v(a,c,f,i,n[h+12],11,-421815835),i=v(i,a,c,f,n[h+15],16,530742520),c=m(c,f=v(f,i,a,c,n[h+2],23,-995338651),i,a,n[h],6,-198630844),a=m(a,c,f,i,n[h+7],10,1126891415),i=m(i,a,c,f,n[h+14],15,-1416354905),f=m(f,i,a,c,n[h+5],21,-57434055),c=m(c,f,i,a,n[h+12],6,1700485571),a=m(a,c,f,i,n[h+3],10,-1894986606),i=m(i,a,c,f,n[h+10],15,-1051523),f=m(f,i,a,c,n[h+1],21,-2054922799),c=m(c,f,i,a,n[h+8],6,1873313359),a=m(a,c,f,i,n[h+15],10,-30611744),i=m(i,a,c,f,n[h+6],15,-1560198380),f=m(f,i,a,c,n[h+13],21,1309151649),c=m(c,f,i,a,n[h+4],6,-145523070),a=m(a,c,f,i,n[h+11],10,-1120210379),i=m(i,a,c,f,n[h+2],15,718787259),f=m(f,i,a,c,n[h+9],21,-343485551),c=d(c,r),f=d(f,e),i=d(i,o),a=d(a,u);return[c,f,i,a]}function i(n){for(var t="",r=32*n.length,e=0;e<r;e+=8)t+=String.fromCharCode(n[e>>5]>>>e%32&255);return t}function a(n){var t=[];for(t[(n.length>>2)-1]=void 0,e=0;e<t.length;e+=1)t[e]=0;for(var r=8*n.length,e=0;e<r;e+=8)t[e>>5]|=(255&n.charCodeAt(e/8))<<e%32;return t}function e(n){for(var t,r="0123456789abcdef",e="",o=0;o<n.length;o+=1)t=n.charCodeAt(o),e+=r.charAt(t>>>4&15)+r.charAt(15&t);return e}function r(n){return unescape(encodeURIComponent(n))}function o(n){return i(c(a(n=r(n)),8*n.length))}function u(n,t){return function(n,t){var r,e=a(n),o=[],u=[];for(o[15]=u[15]=void 0,16<e.length&&(e=c(e,8*n.length)),r=0;r<16;r+=1)o[r]=909522486^e[r],u[r]=1549556828^e[r];return t=c(o.concat(a(t)),512+8*t.length),i(c(u.concat(t),640))}(r(n),r(t))}function t(n,t,r){return t?r?u(t,n):e(u(t,n)):r?o(n):e(o(n))}"function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:n.md5=t}(this);
console.log('‚úÖ MD5 loaded successfully (self-contained)');
    </script>
    
    <style>
        :root {
            --primary-bg: #0f172a;
            --secondary-bg: #1e293b;
            --accent: #3b82f6;
            --success: #10b981;
            --danger: #ef4444;
            --text: #e2e8f0;
            --text-muted: #94a3b8;
            --border: #334155;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);
            min-height: 100vh;
            color: var(--text);
            line-height: 1.6;
            padding: 2rem;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 3rem;
        }
        
        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(59, 130, 246, 0.1);
            color: var(--accent);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            border: 1px solid rgba(59, 130, 246, 0.2);
            transition: all 0.2s;
            margin-bottom: 2rem;
        }
        
        .back-button:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: translateY(-1px);
        }
        
        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
            margin-bottom: 2rem;
        }
        
        .search-card {
            background: var(--secondary-bg);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        
        .search-form {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        input {
            flex: 1;
            background: var(--primary-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            color: var(--text);
            font-size: 1rem;
            font-family: 'Monaco', 'Courier New', monospace;
        }
        
        input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        input::placeholder {
            color: var(--text-muted);
        }
        
        button {
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        button:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #334155;
            cursor: not-allowed;
            transform: none;
        }
        
        .hint {
            color: var(--text-muted);
            font-size: 0.875rem;
            text-align: center;
        }
        
        .results {
            background: var(--secondary-bg);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 2rem;
            display: none;
        }
        
        .results.show {
            display: block;
        }
        
        .loading {
            text-align: center;
            padding: 3rem;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .success-icon {
            font-size: 3rem;
            text-align: center;
            margin-bottom: 1rem;
        }
        
        .result-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .result-section {
            margin: 1.5rem 0;
        }
        
        .result-label {
            color: var(--text-muted);
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }
        
        .result-value {
            background: var(--primary-bg);
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Monaco', 'Courier New', monospace;
            word-break: break-all;
            border: 1px solid var(--border);
        }
        
        .hash-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .hash-item {
            background: var(--primary-bg);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .hash-algorithm {
            color: var(--accent);
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .hash-value {
            font-family: 'Monaco', 'Courier New', monospace;
            word-break: break-all;
            font-size: 0.875rem;
        }
        
        .blockchain-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            border: 1px solid rgba(16, 185, 129, 0.2);
            transition: all 0.2s;
            margin-top: 1rem;
        }
        
        .blockchain-link:hover {
            background: rgba(16, 185, 129, 0.2);
            transform: translateY(-1px);
        }
        
        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            color: var(--danger);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .metric {
            background: var(--primary-bg);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            text-align: center;
        }
        
        .metric-label {
            color: var(--text-muted);
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        
        .metric-value {
            color: var(--success);
            font-size: 1.25rem;
            font-weight: 700;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .progress-tier {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 0.875rem;
        }
        
        .tier-1 { background-color: #10b981; color: white; }
        .tier-2 { background-color: #f59e0b; color: white; }
        .tier-3 { background-color: #ef4444; color: white; }
        
        .cancel-btn {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
        }
        
        .cancel-btn:hover {
            background: rgba(239, 68, 68, 0.2);
        }
        
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 1rem;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s ease;
        }
        
        .progress-stats {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            font-size: 0.875rem;
            color: var(--text-muted);
        }
        
        .action-buttons {
            text-align: center;
            margin-top: 1.5rem;
        }
        
        .view-button {
            display: inline-block;
            background: var(--accent);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .view-button:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }
        
        @media (max-width: 640px) {
            body { padding: 1rem; }
            h1 { font-size: 2rem; }
            .search-form { flex-direction: column; }
            button { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="index.html" class="back-button">
                üè† ArcHive
            </a>
            <h1>üîó Link Explorer</h1>
            <p class="subtitle">Check if a link has been archived and verify it hasn't changed since</p>
        </div>
        
        <div class="info-card" style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.2); padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;">
            <h3 style="margin: 0 0 1rem 0; color: #60a5fa;">How It Works</h3>
            <ol style="margin: 0; padding-left: 1.5rem; line-height: 1.8;">
                <li>Paste the URL you want to verify</li>
                <li>We'll search the Hive blockchain for archived copies</li>
                <li>If found, you can compare hashes to see if content changed</li>
            </ol>
        </div>
        
        <div class="search-card">
            <form class="search-form" onsubmit="event.preventDefault(); processInput();">
                <input 
                    type="url" 
                    id="urlInput" 
                    placeholder="Enter URL to verify (e.g., https://x.com/post/123)..."
                    autocomplete="off"
                    spellcheck="false"
                >
                <button type="submit" id="processButton">Verify Link</button>
            </form>
            <p class="hint" id="inputHint">Enter a URL to verify if it has been archived on the blockchain</p>
            
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border);">
                <label for="htmlInput" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text);">
                    Optional: Paste current page HTML to verify content integrity
                </label>
                <textarea id="htmlInput" placeholder="Paste HTML to compare hashes (optional)..." style="width: 100%; min-height: 150px; background: var(--primary-bg); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; color: var(--text); font-size: 1rem; font-family: 'Monaco', 'Courier New', monospace; resize: vertical;"></textarea>
                <div style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
                    üí° Tip: Visit the URL, right-click ‚Üí "View Page Source", copy all HTML and paste here to verify integrity
                </div>
            </div>
            
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border); display: flex; gap: 1rem; align-items: center;">
                <button type="button" onclick="viewCacheStats()" style="flex: 1; background: rgba(139, 92, 246, 0.1); color: #8b5cf6; border: 1px solid rgba(139, 92, 246, 0.2);">
                    üìä Cache Stats
                </button>
                <button type="button" onclick="clearCacheConfirm()" style="flex: 1; background: rgba(239, 68, 68, 0.1); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.2);">
                    üóëÔ∏è Clear Cache
                </button>
            </div>
        </div>
        
        <div class="results" id="results"></div>
    </div>
    
    <script src="static/js/url-normalizer.js?v=1763761129"></script>
    <script src="static/js/hive-lookup.js?v=1763761129"></script>
    <script src="static/js/multipart-content.js?v=1763761129"></script>
    <script>
        console.log('üîó Link Explorer JavaScript Loading...');
        
        // Wrap entire script in IIFE to avoid global scope pollution
        (function() {
            // Import all functions from hive-lookup module
            // IIFE creates local scope, preventing global conflicts with hive-lookup.js functions
            const {
                fetchHiveAPIWithFailover,
                searchHiveByTags,
                generateContentHash,
                extractContentFromHTML,
                countWords,
                harvestMetadata,
                generateArchiveTags,
                extractHashesFromMetadata,
                compareHashes
            } = window.ArcHiveHiveLookup;
            
            // Import multi-part functions from multipart-content module
            const {
                extractManifestFromPost,
                parseCompactManifest,
                verifyMultiPartContent,
                generateSeriesTag,
                hashMultiPartContent
            } = window.ArcHiveMultiPart || {};
        
        // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        // PHASE 6: MULTI-PART CONTENT INTEGRATION
        // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        
        // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        // TASK 4: THREADED REPLIES ARCHITECTURE SUPPORT
        // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        
        /**
         * Fetch threaded comment replies for multi-part content
         * Uses Hive API bridge.get_discussion to retrieve all replies to a root post
         * Filters and sorts replies by part number for reconstruction
         * 
         * @param {string} author - Root post author
         * @param {string} permlink - Root post permlink (Part 1)
         * @param {number} totalParts - Expected number of parts (from manifest)
         * @param {Function} progressCallback - Optional progress updates: (currentPart, totalParts, status) => void
         * @returns {Promise<Array>} - Array of reply posts sorted by part number
         */
        async function fetchThreadedReplies(author, permlink, totalParts, progressCallback = null) {
            console.log(`üßµ Fetching threaded replies for @${author}/${permlink}...`);
            console.log(`   Expected: ${totalParts} total parts (1 root + ${totalParts - 1} replies)`);
            
            if (progressCallback) {
                progressCallback(1, totalParts, 'discovering');
            }
            
            try {
                // Step 1: Get the root post first
                const getRootParams = {
                    jsonrpc: '2.0',
                    method: 'condenser_api.get_content',
                    params: [author, permlink],
                    id: 1
                };
                
                console.log('üîå Fetching root post from Hive API...');
                const rootPost = await fetchHiveAPIWithFailover(getRootParams, 2, (nodeIndex, totalNodes, nodeName, retry) => {
                    console.log(`   Trying node ${nodeIndex}/${totalNodes}: ${nodeName}${retry > 0 ? ` (retry ${retry})` : ''}`);
                });
                
                if (!rootPost || !rootPost.author) {
                    throw new Error(`Root post @${author}/${permlink} not found`);
                }
                
                console.log(`‚úÖ Root post found (Part 1)`);
                
                // Step 2: Get all replies to the root post
                const getRepliesParams = {
                    jsonrpc: '2.0',
                    method: 'condenser_api.get_content_replies',
                    params: [author, permlink],
                    id: 1
                };
                
                console.log('üîå Fetching comment replies from Hive API...');
                const allReplies = await fetchHiveAPIWithFailover(getRepliesParams, 2, (nodeIndex, totalNodes, nodeName, retry) => {
                    console.log(`   Trying node ${nodeIndex}/${totalNodes}: ${nodeName}${retry > 0 ? ` (retry ${retry})` : ''}`);
                });
                
                console.log(`‚úÖ Replies fetched successfully`);
                console.log(`üìä Found ${allReplies.length} total replies to root post`);
                
                // Filter for replies by the same author (exclude external comments)
                const authorReplies = allReplies.filter(post => post.author === author);
                
                console.log(`üìù Found ${authorReplies.length} replies by @${author} (excluding external comments)`);
                
                // Extract part numbers from permlinks
                // Expected format: {series_id}-part-{N}
                const partsWithNumbers = authorReplies.map(post => {
                    // Try to extract part number from permlink
                    // Format examples: "abc123-part-2", "xyz-part-3", etc.
                    const partMatch = post.permlink.match(/-part-(\d+)$/i);
                    const partNumber = partMatch ? parseInt(partMatch[1], 10) : null;
                    
                    return {
                        post: post,
                        partNumber: partNumber,
                        permlink: post.permlink
                    };
                });
                
                // Filter out any replies that don't match the part number pattern
                const validParts = partsWithNumbers.filter(item => item.partNumber !== null);
                
                if (validParts.length === 0) {
                    console.warn('‚ö†Ô∏è  No valid part numbers found in reply permlinks');
                    console.warn('   Expected format: {series_id}-part-{N}');
                    console.warn('   Found permlinks:', authorReplies.map(p => p.permlink));
                }
                
                console.log(`‚úÖ Found ${validParts.length} replies with valid part numbers`);
                
                // Sort replies by part number (ascending)
                validParts.sort((a, b) => a.partNumber - b.partNumber);
                
                // Combine root post (Part 1) + sorted replies (Parts 2+)
                const allParts = [{
                    post: rootPost,
                    partNumber: 1,
                    permlink: permlink
                }, ...validParts];
                
                // Validate part sequence (check for gaps)
                const expectedPartNumbers = Array.from({length: totalParts}, (_, i) => i + 1);
                const actualPartNumbers = allParts.map(item => item.partNumber);
                const missingParts = expectedPartNumbers.filter(num => !actualPartNumbers.includes(num));
                
                if (missingParts.length > 0) {
                    console.warn(`‚ö†Ô∏è  Missing parts: ${missingParts.join(', ')}`);
                    console.warn(`   Expected: ${expectedPartNumbers.join(', ')}`);
                    console.warn(`   Found: ${actualPartNumbers.join(', ')}`);
                }
                
                // Check for duplicate part numbers
                const duplicates = actualPartNumbers.filter((num, idx) => 
                    actualPartNumbers.indexOf(num) !== idx
                );
                if (duplicates.length > 0) {
                    console.warn(`‚ö†Ô∏è  Duplicate part numbers detected: ${duplicates.join(', ')}`);
                }
                
                console.log(`‚úÖ Threaded replies assembled: ${allParts.length}/${totalParts} parts`);
                console.log(`   Part sequence: ${allParts.map(p => p.partNumber).join(' ‚Üí ')}`);
                
                if (progressCallback) {
                    progressCallback(allParts.length, totalParts, 'complete');
                }
                
                // Return posts in order (without the metadata wrapper)
                return allParts.map(item => item.post);
                
            } catch (error) {
                console.error('‚ùå Failed to fetch threaded replies:', error.message);
                
                if (progressCallback) {
                    progressCallback(1, totalParts, 'error');
                }
                
                throw new Error(`Failed to fetch threaded replies: ${error.message}`);
            }
        }
        
        /**
         * Detect multi-part manifest in a Hive post
         * Checks json_metadata.arcMultiPart and falls back to compact HTML comment
         * 
         * @param {Object} post - Hive post object
         * @returns {Object|null} - Normalized manifest or null for single-part
         */
        function detectManifest(post) {
            if (!extractManifestFromPost) {
                console.warn('‚ö†Ô∏è  Multi-part module not loaded - skipping manifest detection');
                return null;
            }
            
            try {
                const manifest = extractManifestFromPost(post);
                if (!manifest) {
                    return null;
                }
                
                // Normalize manifest structure (handle both compact and full formats)
                const normalized = {
                    series_id: manifest.series_id || manifest.s,
                    total_parts: manifest.total_parts || manifest.t,
                    current_part: manifest.current_part || manifest.p,
                    content_hash_full: manifest.content_hash_full || manifest.h,
                    source_url: manifest.source_url || manifest.u,
                    parts: manifest.parts || [],
                    part_hashes: manifest.part_hashes || []
                };
                
                // Validate critical fields
                if (!normalized.series_id || !normalized.total_parts) {
                    console.warn('‚ö†Ô∏è  Incomplete manifest - missing series_id or total_parts');
                    return null;
                }
                
                console.log(`üì¶ Multi-part manifest detected: ${normalized.total_parts} parts, series ${normalized.series_id.substring(0, 8)}...`);
                return normalized;
                
            } catch (error) {
                console.warn('‚ö†Ô∏è  Manifest detection failed:', error.message);
                return null;
            }
        }
        
        /**
         * Find all parts of a multi-part series using SERIES tag
         * Uses client-side filtering to prevent cross-series contamination
         * 
         * @param {Object} manifest - Normalized manifest object
         * @param {Function} progressCallback - Progress callback (partNumber, totalParts, status)
         * @returns {Promise<Array>} - Array of post objects sorted by part_number
         */
        async function findSeriesParts(manifest, progressCallback = null) {
            console.log(`üîç Searching for ${manifest.total_parts} parts of series ${manifest.series_id.substring(0, 8)}...`);
            
            try {
                // Generate SERIES tag for this series
                const seriesTag = generateSeriesTag(manifest.series_id);
                console.log(`üè∑Ô∏è  Using discovery tag: ${seriesTag}`);
                
                // Search for all posts with this SERIES tag
                const searchTags = ['archivedcontenthaf', seriesTag];
                const allPosts = await searchHiveByTags(searchTags);
                
                console.log(`üìä Found ${allPosts.length} posts with ${seriesTag} tag`);
                
                // Filter posts that match this specific series_id
                const seriesPosts = [];
                const postCache = new Map(); // Cache to avoid duplicate lookups
                
                for (const post of allPosts) {
                    // Extract manifest from this post
                    const postManifest = detectManifest(post);
                    
                    if (!postManifest) {
                        continue; // Skip posts without valid manifest
                    }
                    
                    // CRITICAL: Only accept posts from the SAME series
                    if (postManifest.series_id !== manifest.series_id) {
                        console.log(`‚ö†Ô∏è  Skipping post from different series: ${postManifest.series_id.substring(0, 8)}...`);
                        continue;
                    }
                    
                    // Determine part number for this post
                    const partNumber = postManifest.current_part || 1;
                    
                    // Cache post metadata to avoid duplicate lookups
                    postCache.set(partNumber, {
                        part_number: partNumber,
                        author: post.author,
                        permlink: post.permlink,
                        post_data: post,
                        manifest: postManifest
                    });
                    
                    seriesPosts.push(postCache.get(partNumber));
                    
                    console.log(`‚úÖ Found part ${partNumber}/${manifest.total_parts}: @${post.author}/${post.permlink}`);
                    
                    // Report progress
                    if (progressCallback) {
                        progressCallback(seriesPosts.length, manifest.total_parts, 'discovered');
                    }
                }
                
                // Sort by part_number for consistent ordering
                seriesPosts.sort((a, b) => a.part_number - b.part_number);
                
                console.log(`‚úÖ Series discovery complete: Found ${seriesPosts.length}/${manifest.total_parts} parts`);
                
                return seriesPosts;
                
            } catch (error) {
                console.error('‚ùå Series part discovery failed:', error);
                throw new Error(`Failed to find series parts: ${error.message}`);
            }
        }
        
        /**
         * Fetch all parts of a series in parallel with failover
         * Uses Promise.all() with individual failover for each part
         * 
         * @param {Array} seriesParts - Array from findSeriesParts()
         * @param {number} totalParts - Expected total parts
         * @param {Function} progressCallback - Progress callback (part, totalParts, status)
         * @returns {Promise<Object>} - {success, parts, missing, errors}
         */
        async function fetchSeriesParts(seriesParts, totalParts, progressCallback = null) {
            console.log(`üì• Fetching ${totalParts} parts in parallel...`);
            
            const parts = new Array(totalParts).fill(null);
            const missing = [];
            const errors = [];
            
            // Create fetch promises for all parts
            const fetchPromises = seriesParts.map(async (partInfo) => {
                const partNumber = partInfo.part_number;
                
                try {
                    // Report progress
                    if (progressCallback) {
                        progressCallback(partNumber, totalParts, 'fetching');
                    }
                    
                    // Part data is already in post_data from discovery
                    const post = partInfo.post_data;
                    
                    // Extract content from post body
                    // Remove manifest HTML comment if present
                    let content = post.body;
                    
                    // FIX BUG #3: Use [\s\S]*? to match multi-line manifests (. doesn't match newlines)
                    const beforeLength = content.length;
                    content = content.replace(/<!--ARCHIVE-MANIFEST:[\s\S]*?-->/g, '');
                    const afterLength = content.length;
                    
                    if (beforeLength === afterLength) {
                        console.warn(`‚ö†Ô∏è  Part ${partNumber}: No manifest found in post body`);
                    }
                    
                    content = content.trim();
                    
                    // Store in correct position (0-indexed array, 1-indexed part numbers)
                    parts[partNumber - 1] = {
                        part_number: partNumber,
                        content: content,
                        author: partInfo.author,
                        permlink: partInfo.permlink,
                        post_data: post
                    };
                    
                    console.log(`‚úÖ Part ${partNumber} fetched (${content.length} chars)`);
                    
                    // Report success
                    if (progressCallback) {
                        progressCallback(partNumber, totalParts, 'success');
                    }
                    
                } catch (error) {
                    console.error(`‚ùå Failed to fetch part ${partNumber}:`, error);
                    errors.push({
                        part_number: partNumber,
                        error: error.message
                    });
                    
                    // Report error
                    if (progressCallback) {
                        progressCallback(partNumber, totalParts, 'error');
                    }
                }
            });
            
            // Wait for all fetches to complete
            await Promise.all(fetchPromises);
            
            // Identify missing parts
            for (let i = 0; i < totalParts; i++) {
                if (parts[i] === null) {
                    missing.push(i + 1);
                }
            }
            
            const success = missing.length === 0 && errors.length === 0;
            
            console.log(`üìä Fetch complete: ${parts.filter(p => p !== null).length}/${totalParts} parts retrieved`);
            if (missing.length > 0) {
                console.warn(`‚ö†Ô∏è  Missing parts: ${missing.join(', ')}`);
            }
            if (errors.length > 0) {
                console.error(`‚ùå Errors: ${errors.length} parts failed`);
            }
            
            return {
                success: success,
                parts: parts,
                missing: missing,
                errors: errors
            };
        }
        
        /**
         * Reassemble and verify multi-part content
         * Sorts parts, concatenates content, and verifies all hashes
         * 
         * @param {Array} parts - Array of part objects from fetchSeriesParts()
         * @param {Object} manifest - Normalized manifest with expected hashes
         * @returns {Promise<Object>} - {reassembled, verified, errors, partVerifications}
         */
        async function reassembleContent(parts, manifest) {
            console.log(`üîó Reassembling ${parts.length} parts...`);
            
            try {
                // Filter out null parts (missing parts)
                const validParts = parts.filter(p => p !== null);
                
                if (validParts.length === 0) {
                    throw new Error('No valid parts to reassemble');
                }
                
                // Check if all parts are present
                const allPartsPresent = validParts.length === manifest.total_parts;
                
                if (!allPartsPresent) {
                    const missingCount = manifest.total_parts - validParts.length;
                    console.warn(`‚ö†Ô∏è  Incomplete series: ${validParts.length}/${manifest.total_parts} parts found (${missingCount} missing)`);
                    console.warn('‚ö†Ô∏è  Skipping verification - cannot verify incomplete content');
                    
                    // Return early with partial content but no verification
                    return {
                        reassembled: validParts.map(p => p.content).join(''),
                        verified: false,
                        errors: [`Incomplete series: ${missingCount} of ${manifest.total_parts} parts are missing from the blockchain`],
                        partVerifications: [],
                        incomplete: true
                    };
                }
                
                // Sort by part_number (handle out-of-order fetching)
                validParts.sort((a, b) => a.part_number - b.part_number);
                
                // Extract content strings in order
                // CRITICAL: Strip manifest comments before hashing to match original content
                // During archiving: content is hashed FIRST, THEN manifest is added
                // During verification: content has manifest, must strip before hashing
                const contentParts = validParts.map(p => {
                    const { stripManifestComment } = window.ArcHiveMultiPart || {};
                    return stripManifestComment ? stripManifestComment(p.content) : p.content;
                });
                
                console.log(`  üìù Stripped manifest comments from ${validParts.length} parts before verification`);
                
                // Concatenate to create full content
                const reassembled = contentParts.join('');
                
                console.log(`üìè Reassembled content: ${reassembled.length} chars from ${validParts.length} parts`);
                
                // Verify content integrity using dual hash system (with error handling)
                let verification = null;
                let verificationErrors = [];
                
                try {
                    if (!verifyMultiPartContent) {
                        console.warn('‚ö†Ô∏è  Multi-part verification module not loaded - skipping hash verification');
                        verificationErrors.push('Verification module not available');
                    } else {
                        // Extract expected hashes from manifest
                        const expectedHashes = {
                            partHashes: manifest.part_hashes || [],
                            fullContentHash: manifest.content_hash_full
                        };
                        
                        console.log('üîê Expected hashes extracted:', {
                            partHashesCount: expectedHashes.partHashes.length,
                            hasFullHash: !!expectedHashes.fullContentHash
                        });
                        
                        // Verify all hashes (per-part and full-content)
                        verification = await verifyMultiPartContent(contentParts, expectedHashes);
                        
                        if (!verification.valid) {
                            // Log verification failure details
                            if (verification.reason) {
                                console.warn('‚ö†Ô∏è  Verification failed:', verification.reason);
                            }
                            
                            if (!verification.allPartsValid) {
                                verificationErrors.push('One or more part hashes failed verification');
                            }
                            if (!verification.fullHashValid) {
                                verificationErrors.push('Full content hash failed verification');
                            }
                        } else {
                            console.log('‚úÖ All hashes verified successfully!');
                        }
                    }
                } catch (verifyError) {
                    console.error('‚ùå Hash verification failed:', verifyError);
                    console.warn('‚ö†Ô∏è  Continuing with unverified content...');
                    verificationErrors.push(verifyError.message || 'Hash verification crashed');
                }
                
                // ALWAYS return the reassembled content, even if verification failed
                return {
                    reassembled: reassembled,
                    verified: verification ? verification.valid : false,
                    errors: verificationErrors,
                    partVerifications: verification ? verification.partVerifications : [],
                    fullHashMatches: verification ? verification.fullHashMatches : null
                };
                
            } catch (error) {
                console.error('‚ùå Content reassembly failed:', error);
                return {
                    reassembled: '',
                    verified: false,
                    errors: [error.message],
                    partVerifications: []
                };
            }
        }
        
        /**
         * Generate multi-part UI with banner, part status table, and toggle
         * 
         * @param {Object} manifest - Normalized manifest object
         * @param {Array} fetchedParts - Array of fetched parts
         * @param {Object} reassemblyResult - Result from reassembleContent()
         * @param {string} sourceUrl - Source URL
         * @param {string} searchMethod - Search method description
         * @returns {string} - HTML string for multi-part UI
         */
        function generateMultiPartUI(manifest, fetchedParts, reassemblyResult, sourceUrl, searchMethod) {
            const seriesIdShort = manifest.series_id.substring(0, 8) + '...';
            const seriesTag = generateSeriesTag ? generateSeriesTag(manifest.series_id) : 'SERIES';
            
            // Build part status table
            let partStatusRows = '';
            for (let i = 0; i < manifest.total_parts; i++) {
                const partNumber = i + 1;
                const part = fetchedParts[i];
                
                let status = '‚ö†Ô∏è Missing';
                let statusColor = '#f59e0b';
                let author = '‚Äî';
                let permlink = '';
                let hiveLink = '';
                
                if (part) {
                    // Check verification status
                    const verification = reassemblyResult.partVerifications?.[i];
                    
                    if (verification && verification.valid) {
                        status = '‚úÖ Verified';
                        statusColor = '#10b981';
                    } else if (verification && !verification.valid) {
                        status = '‚ùå Corrupted';
                        statusColor = '#ef4444';
                    } else {
                        status = '‚úì Fetched';
                        statusColor = '#3b82f6';
                    }
                    
                    author = '@' + part.author;
                    permlink = part.permlink;
                    hiveLink = `<a href="https://ecency.com/@${part.author}/${part.permlink}" target="_blank" style="color: #3b82f6; text-decoration: none;">View on Hive ‚Üí</a>`;
                }
                
                partStatusRows += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem; text-align: center; font-weight: 600;">${partNumber}</td>
                        <td style="padding: 0.75rem; color: ${statusColor}; font-weight: 600;">${status}</td>
                        <td style="padding: 0.75rem; font-family: 'Monaco', monospace; font-size: 0.9rem;">${author}</td>
                        <td style="padding: 0.75rem;">${hiveLink}</td>
                    </tr>
                `;
            }
            
            // Verification banner
            let verificationBanner = '';
            if (reassemblyResult.verified) {
                verificationBanner = `
                    <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 1.25rem; border-radius: 8px; margin-bottom: 1.5rem;">
                        <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 0.5rem;">‚úÖ MULTI-PART CONTENT VERIFIED</div>
                        <div style="font-size: 0.95rem; opacity: 0.95;">All ${manifest.total_parts} parts verified. Content integrity confirmed via dual-hash verification (per-part + full-content).</div>
                    </div>
                `;
            } else if (reassemblyResult.reassembled && reassemblyResult.reassembled.length > 0) {
                // Content available but verification failed - show WARNING (yellow) not ERROR (red)
                const errorList = reassemblyResult.errors.map(e => `<li>${e}</li>`).join('');
                verificationBanner = `
                    <div style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; padding: 1.25rem; border-radius: 8px; margin-bottom: 1.5rem;">
                        <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 0.5rem;">‚ö†Ô∏è VERIFICATION ISSUES</div>
                        <div style="font-size: 0.95rem; opacity: 0.95; margin-bottom: 0.75rem;">Content reassembled successfully, but cryptographic verification encountered errors:</div>
                        <ul style="margin: 0; padding-left: 1.5rem; font-size: 0.9rem;">${errorList}</ul>
                        <div style="font-size: 0.85rem; opacity: 0.9; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.3);">
                            üí° <strong>Note:</strong> Content is available below. The verification error may be due to missing hash metadata or incompatible hash format in the blockchain record.
                        </div>
                    </div>
                `;
            } else {
                // No content available - show ERROR (red)
                const errorList = reassemblyResult.errors.map(e => `<li>${e}</li>`).join('');
                verificationBanner = `
                    <div style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; padding: 1.25rem; border-radius: 8px; margin-bottom: 1.5rem;">
                        <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 0.5rem;">‚ùå VERIFICATION FAILED</div>
                        <div style="font-size: 0.95rem; opacity: 0.95; margin-bottom: 0.75rem;">Multi-part content verification failed:</div>
                        <ul style="margin: 0; padding-left: 1.5rem; font-size: 0.9rem;">${errorList}</ul>
                    </div>
                `;
            }
            
            // Build full UI
            const html = `
                <div class="success-icon">üì¶</div>
                <h2 class="result-title">Multi-Part Series Detected</h2>
                
                <!-- Search info banner -->
                <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.2); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; font-size: 0.9rem;">
                    <strong>üîç Search method:</strong> ${searchMethod}<br>
                    <strong>üì¶ Series type:</strong> ${manifest.total_parts}-Part Multi-Part Archive<br>
                    <strong>üîñ Series ID:</strong> ${seriesIdShort}<br>
                    <strong>üè∑Ô∏è Discovery tag:</strong> ${seriesTag}
                </div>
                
                ${verificationBanner}
                
                <!-- Source URL -->
                <div style="background: var(--secondary-bg); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                    <div style="font-weight: 600; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.5px;">üìç Archived URL</div>
                    <div style="font-family: 'Monaco', 'Courier New', monospace; font-size: 0.9rem; color: var(--accent); word-break: break-all;">
                        <a href="${escapeHtml(sourceUrl)}" target="_blank" style="color: #3b82f6; text-decoration: none;">${escapeHtml(sourceUrl)}</a>
                    </div>
                </div>
                
                <!-- Part Status Table -->
                <div style="background: var(--primary-bg); border: 2px solid var(--border); border-radius: 12px; padding: 0; margin-bottom: 1.5rem; overflow: hidden;">
                    <div style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); padding: 1rem; color: white;">
                        <div style="font-weight: 700; font-size: 1.1rem;">üìä Part Status Overview</div>
                        <div style="font-size: 0.85rem; opacity: 0.9; margin-top: 0.25rem;">${manifest.total_parts} total parts ‚Ä¢ ${fetchedParts.filter(p => p !== null).length} fetched ‚Ä¢ ${reassemblyResult.verified ? 'All verified ‚úÖ' : 'Verification issues ‚ö†Ô∏è'}</div>
                    </div>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: var(--secondary-bg); border-bottom: 2px solid var(--border);">
                                    <th style="padding: 0.75rem; text-align: center; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px;">Part #</th>
                                    <th style="padding: 0.75rem; text-align: left; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px;">Status</th>
                                    <th style="padding: 0.75rem; text-align: left; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px;">Author</th>
                                    <th style="padding: 0.75rem; text-align: left; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px;">Blockchain Link</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${partStatusRows}
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- View Toggle -->
                <div id="multipart-toggle-container" style="margin-bottom: 1.5rem;">
                    <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                        <button onclick="showUnifiedView()" id="btn-unified" style="flex: 1; padding: 0.75rem 1.5rem; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.95rem; transition: all 0.2s;">
                            üìÑ Unified Article
                        </button>
                        <button onclick="showIndividualView()" id="btn-individual" style="flex: 1; padding: 0.75rem 1.5rem; background: var(--secondary-bg); color: var(--text); border: 1px solid var(--border); border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.95rem; transition: all 0.2s;">
                            üìë View Parts Individually
                        </button>
                    </div>
                    
                    <!-- Unified view (default) -->
                    <div id="unified-view" style="display: block;">
                        <div style="background: var(--secondary-bg); border: 1px solid var(--border); border-radius: 8px; padding: 1.25rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                                <div style="font-weight: 600; font-size: 0.95rem; color: var(--text);">
                                    üîó Reassembled Content (${reassemblyResult.reassembled.length.toLocaleString()} characters)
                                </div>
                                <button onclick="openFullContentModal()" style="padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85rem; transition: all 0.2s;">
                                    üîç View Full Content
                                </button>
                            </div>
                            <div style="max-height: 400px; overflow-y: auto; font-family: 'Monaco', 'Courier New', monospace; font-size: 0.85rem; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; background: var(--primary-bg); padding: 1rem; border-radius: 4px; border: 1px solid var(--border);">
${escapeHtml(reassemblyResult.reassembled.substring(0, 5000))}${reassemblyResult.reassembled.length > 5000 ? '\n\n... [Content truncated for display - click "View Full Content" to see all] ...' : ''}
                            </div>
                        </div>
                    </div>
                    
                    <!-- Individual parts view (hidden by default) -->
                    <div id="individual-view" style="display: none;">
                        ${fetchedParts.filter(p => p !== null).map((part, idx) => {
                            const verification = reassemblyResult.partVerifications?.[idx];
                            const verified = verification && verification.valid;
                            const verifiedBadge = verified ? '<span style="color: #10b981; font-weight: 600;">‚úÖ Verified</span>' : '<span style="color: #f59e0b; font-weight: 600;">‚ö†Ô∏è Unverified</span>';
                            
                            return `
                                <div style="background: var(--secondary-bg); border: 1px solid var(--border); border-radius: 8px; padding: 1.25rem; margin-bottom: 1rem;">
                                    <div style="font-weight: 600; font-size: 0.95rem; color: var(--text); margin-bottom: 0.5rem;">
                                        Part ${part.part_number} of ${manifest.total_parts} ${verifiedBadge}
                                    </div>
                                    <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 1rem;">
                                        @${part.author}/${part.permlink}
                                    </div>
                                    <div style="max-height: 200px; overflow-y: auto; font-family: 'Monaco', 'Courier New', monospace; font-size: 0.85rem; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; background: var(--primary-bg); padding: 1rem; border-radius: 4px; border: 1px solid var(--border);">
${escapeHtml(part.content.substring(0, 1000))}${part.content.length > 1000 ? '\n\n... [Content truncated for display] ...' : ''}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                
                <!-- Full Content Hash -->
                <div style="background: var(--secondary-bg); border: 1px solid var(--border); border-radius: 8px; padding: 1.25rem;">
                    <div style="font-weight: 600; font-size: 0.95rem; color: var(--text); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span>üîê</span>
                        <span>Full Content Cryptographic Hash</span>
                    </div>
                    <div style="font-family: 'Monaco', 'Courier New', monospace; font-size: 0.8rem; line-height: 1.8; color: var(--text-muted);">
                        ${manifest.content_hash_full?.sha256 ? `
                            <div style="margin-bottom: 0.75rem;">
                                <div style="color: var(--text); font-weight: 600; margin-bottom: 0.25rem;">SHA-256:</div>
                                <div style="word-break: break-all; background: var(--primary-bg); padding: 0.5rem; border-radius: 4px; border: 1px solid var(--border);">${manifest.content_hash_full.sha256}</div>
                            </div>
                        ` : ''}
                        ${manifest.content_hash_full?.blake2b ? `
                            <div style="margin-bottom: 0.75rem;">
                                <div style="color: var(--text); font-weight: 600; margin-bottom: 0.25rem;">BLAKE2b:</div>
                                <div style="word-break: break-all; background: var(--primary-bg); padding: 0.5rem; border-radius: 4px; border: 1px solid var(--border);">${manifest.content_hash_full.blake2b}</div>
                            </div>
                        ` : ''}
                        ${manifest.content_hash_full?.md5 ? `
                            <div>
                                <div style="color: var(--text); font-weight: 600; margin-bottom: 0.25rem;">MD5:</div>
                                <div style="word-break: break-all; background: var(--primary-bg); padding: 0.5rem; border-radius: 4px; border: 1px solid var(--border);">${manifest.content_hash_full.md5}</div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            
            return html;
        }
        
        /**
         * Global storage for full content (for modal)
         */
        let _fullContentCache = '';
        
        /**
         * Toggle functions for unified/individual view
         */
        function showUnifiedView() {
            document.getElementById('unified-view').style.display = 'block';
            document.getElementById('individual-view').style.display = 'none';
            document.getElementById('btn-unified').style.background = '#3b82f6';
            document.getElementById('btn-unified').style.color = 'white';
            document.getElementById('btn-unified').style.border = 'none';
            document.getElementById('btn-individual').style.background = 'var(--secondary-bg)';
            document.getElementById('btn-individual').style.color = 'var(--text)';
            document.getElementById('btn-individual').style.border = '1px solid var(--border)';
        }
        
        function showIndividualView() {
            document.getElementById('unified-view').style.display = 'none';
            document.getElementById('individual-view').style.display = 'block';
            document.getElementById('btn-individual').style.background = '#3b82f6';
            document.getElementById('btn-individual').style.color = 'white';
            document.getElementById('btn-individual').style.border = 'none';
            document.getElementById('btn-unified').style.background = 'var(--secondary-bg)';
            document.getElementById('btn-unified').style.color = 'var(--text)';
            document.getElementById('btn-unified').style.border = '1px solid var(--border)';
        }
        
        /**
         * Open full content modal
         */
        function openFullContentModal() {
            // Create modal if it doesn't exist
            let modal = document.getElementById('fullContentModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'fullContentModal';
                modal.innerHTML = `
                    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; display: flex; align-items: center; justify-content: center; padding: 2rem;">
                        <div style="background: var(--primary-bg); border-radius: 12px; max-width: 1200px; width: 100%; max-height: 90vh; display: flex; flex-direction: column; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);">
                            <!-- Modal Header -->
                            <div style="padding: 1.5rem; border-bottom: 2px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); border-radius: 12px 12px 0 0;">
                                <div>
                                    <div style="font-size: 1.25rem; font-weight: 700; color: white; margin-bottom: 0.25rem;">üìÑ Full Archived Content</div>
                                    <div id="modalCharCount" style="font-size: 0.85rem; color: rgba(255,255,255,0.9);"></div>
                                </div>
                                <button onclick="closeFullContentModal()" style="background: rgba(255,255,255,0.2); color: white; border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 1.25rem; line-height: 1; transition: all 0.2s; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                                    √ó
                                </button>
                            </div>
                            <!-- Modal Content -->
                            <div id="modalContentArea" style="flex: 1; overflow-y: auto; padding: 1.5rem; font-family: 'Monaco', 'Courier New', monospace; font-size: 0.9rem; line-height: 1.8; white-space: pre-wrap; word-wrap: break-word; background: var(--secondary-bg); color: var(--text);"></div>
                            <!-- Modal Footer -->
                            <div style="padding: 1rem 1.5rem; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: var(--primary-bg); border-radius: 0 0 12px 12px;">
                                <div style="font-size: 0.85rem; color: var(--text-muted);">
                                    üí° Tip: Use Ctrl+F to search within the content
                                </div>
                                <button onclick="closeFullContentModal()" style="padding: 0.5rem 1.5rem; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3b82f6'">
                                    Close
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            // Update modal content
            const contentArea = document.getElementById('modalContentArea');
            const charCount = document.getElementById('modalCharCount');
            contentArea.textContent = _fullContentCache;
            charCount.textContent = `${_fullContentCache.length.toLocaleString()} characters`;
            
            // Show modal
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }
        
        /**
         * Close full content modal
         */
        function closeFullContentModal() {
            const modal = document.getElementById('fullContentModal');
            if (modal) {
                modal.style.display = 'none';
                document.body.style.overflow = ''; // Restore scrolling
            }
        }
        
        // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        // MAIN SEARCH FUNCTION (with multi-part integration)
        // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        
        // Main search function
        async function searchHash() {
            const urlInput = document.getElementById('urlInput');
            const htmlInput = document.getElementById('htmlInput');
            const resultsDiv = document.getElementById('results');
            
            const url = urlInput.value.trim();
            const html = htmlInput.value.trim();
            
            if (!url) {
                resultsDiv.innerHTML = '<div class="error-message">‚ö†Ô∏è Please enter a URL to verify</div>';
                resultsDiv.classList.add('show');
                return;
            }
            
            // Validate URL
            try {
                new URL(url);
            } catch(e) {
                resultsDiv.innerHTML = '<div class="error-message">‚ùå Invalid URL. Please enter a valid URL (e.g., https://example.com)</div>';
                resultsDiv.classList.add('show');
                return;
            }
            
            // FIX 1: Initialize tags BEFORE try block to prevent undefined errors
            let tags = ['archivedcontenthaf'];
            let searchMethod;
            let currentHashes = null;
            // FIX 2: Track whether smart tags were ACTUALLY generated successfully
            let usedSmartTags = false;
            
            // SMART TAG GENERATION: Use HTML to generate precise tags if provided
            if (html) {
                // Show smart tag generation in progress
                resultsDiv.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p style="color: var(--text-muted);">üè∑Ô∏è Generating smart tags from HTML content...<br><small>Extracting content, computing hashes, and creating precision tags</small></p>
                    </div>
                `;
                resultsDiv.classList.add('show');
                
                try {
                    // Extract content from HTML
                    const content = await extractContentFromHTML(html);
                    const wordCount = countWords(content);
                    
                    // Extract metadata
                    const metadata = harvestMetadata(html);
                    const publicationDate = metadata.publicationDate;
                    
                    // Generate hashes
                    const hashes = await generateContentHash(content);
                    currentHashes = hashes;
                    
                    // Generate smart tags using same logic as main app - only if hashes were computed successfully
                    if (currentHashes?.sha256) {
                        const smartTags = generateArchiveTags({
                            url: url,
                            wordCount: wordCount,
                            publicationDate: publicationDate,
                            lastModified: null, // Not available in Link Explorer
                            hashes: { content: currentHashes }
                        });
                        
                        // FIX 2: Only set usedSmartTags=true if we successfully generated smart tags
                        if (smartTags && smartTags.length > 1) {
                            tags = smartTags;
                            usedSmartTags = true;
                            searchMethod = `smart tags (${tags.length} tags: ${tags.slice(0, 5).join(', ')})`;
                            
                            console.log('‚úÖ Smart tags generated from HTML:', smartTags);
                            console.log(`   Word count: ${wordCount}`);
                            console.log(`   Publication date: ${publicationDate || 'not found'}`);
                        } else {
                            console.warn('‚ö†Ô∏è Smart tag generation returned insufficient tags - falling back to universal tag');
                            searchMethod = 'universal tag + URL matching (smart tags insufficient)';
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Hashes not available - falling back to universal tag');
                        searchMethod = 'universal tag + URL matching (hash generation incomplete)';
                    }
                } catch(e) {
                    console.error('‚ùå Smart tag generation failed:');
                    console.error('   Error message:', e?.message || 'No message');
                    console.error('   Error stack:', e?.stack || 'No stack');
                    console.error('   Error type:', typeof e);
                    console.error('   Error object:', e);
                    console.error('   HTML length:', html?.length);
                    console.error('   URL:', url);
                    // Fallback to universal tag on error (tags already initialized)
                    searchMethod = 'universal tag + URL matching (smart tag generation failed)';
                }
            } else {
                // Fallback: Use universal tag + URL matching
                searchMethod = 'universal tag + URL matching';
            }
            
            // Show loading with search method and progress tracking
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p style="color: var(--text-muted);">üîç Searching Hive blockchain for archived copies...<br><small>Using ${searchMethod}</small></p>
                    <p id="hive-search-progress" style="color: var(--text-muted); font-size: 0.85rem; margin-top: 0.5rem;">Connecting to Hive network...</p>
                    <button onclick="window.ArcHiveHiveLookup.cancelCurrentSearch(); document.getElementById('resultsDiv').classList.remove('show');" style="margin-top: 1rem; padding: 0.5rem 1.5rem; background: rgba(239, 68, 68, 0.1); color: #dc2626; border: none; border-radius: 8px; cursor: pointer; font-size: 0.9rem;">
                        üõë Cancel Search
                    </button>
                </div>
            `;
            resultsDiv.classList.add('show');
            
            // Progress callback for search updates
            function updateSearchProgress(nodeIndex, totalNodes, nodeName, retry) {
                const progressElement = document.getElementById('hive-search-progress');
                if (progressElement) {
                    const retryText = retry > 0 ? ` (retry ${retry})` : '';
                    progressElement.textContent = `Trying node ${nodeIndex}/${totalNodes}: ${nodeName}${retryText}`;
                }
            }
            
            try {
                console.log('üîç Searching for URL:', url);
                console.log('üè∑Ô∏è Using tags:', tags);
                
                // Search Hive with tags and progress callback
                const allPosts = await searchHiveByTags(tags, updateSearchProgress);
                console.log(`üìä Found ${allPosts.length} posts with primary tag: ${tags[1] || tags[0]}`);
                
                // FIX 3: Use usedSmartTags flag instead of html to decide filtering strategy
                // If smart tags were successfully generated, posts are already filtered by all tags
                // If using universal tag only, filter by URL matching
                let posts;
                if (usedSmartTags) {
                    // Smart tags already filtered the results precisely
                    console.log('‚úÖ Using smart tag pre-filtered results');
                    posts = allPosts;
                } else {
                    // Filter posts that contain this URL in the body or metadata
                    console.log('üîç Filtering by URL matching (smart tags not used)');
                    
                    // Use shared normalizer for canonical URL comparison
                    const normalizedSearchUrl = window.ArcHiveUrlNormalizer.normalizeUrl(url);
                    console.log(`üîß Normalized search URL: ${normalizedSearchUrl}`);
                    
                    posts = allPosts.filter(post => {
                        // Parse json_metadata if it's a string (Hive API returns it as string)
                        let metadata = post.json_metadata;
                        if (typeof metadata === 'string') {
                            try {
                                metadata = JSON.parse(metadata);
                            } catch (e) {
                                console.warn('‚ö†Ô∏è  Failed to parse json_metadata for URL matching:', post.post_id);
                                metadata = {};
                            }
                        }
                        metadata = metadata || {};
                        
                        // Check metadata sourceUrl using canonical comparison
                        const metadataSourceUrl = metadata.sourceUrl;
                        if (metadataSourceUrl) {
                            const normalizedMetadata = window.ArcHiveUrlNormalizer.normalizeUrl(metadataSourceUrl);
                            if (normalizedMetadata === normalizedSearchUrl) {
                                console.log(`‚úÖ Match found in metadata: ${metadataSourceUrl}`);
                                return true;
                            }
                        }
                        
                        // Legacy fallback: Check if post body contains the URL (multiple formats)
                        const bodyContainsUrl = post.body && (
                            post.body.toLowerCase().includes(url.toLowerCase()) ||
                            post.body.toLowerCase().includes(normalizedSearchUrl)
                        );
                        
                        if (bodyContainsUrl) {
                            console.log(`‚úÖ Match found in body`);
                        }
                        
                        return bodyContainsUrl;
                    });
                }
                
                console.log(`‚úÖ Found ${posts.length} archives matching criteria`);
                
                if (posts.length === 0) {
                    resultsDiv.innerHTML = `
                        <div class="error-message">
                            <h3 style="margin: 0 0 1rem 0;">‚ùå No Archived Copy Found</h3>
                            <p style="margin: 0 0 1rem 0;">This URL has not been archived to Hive blockchain yet.</p>
                            <p style="margin: 0 0 0.5rem 0;"><strong>Search method:</strong> ${searchMethod}</p>
                            <p style="margin: 0 0 0.5rem 0;"><strong>Searched:</strong> ${allPosts.length} total archives</p>
                            ${html ? '<p style="margin: 0 0 0.5rem 0;"><strong>Smart tags used:</strong> ' + tags.slice(0, 5).join(', ') + '</p>' : ''}
                            <p style="margin: 0;"><strong>Want to archive it?</strong> <a href="archive-paste.html" style="color: #3b82f6;">Use ArcHive Paste ‚Üí</a></p>
                        </div>
                    `;
                    return;
                }
                
                // Sort posts by date (newest first) to prioritize recent archives
                posts.sort((a, b) => new Date(b.created) - new Date(a.created));
                
                // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
                // MULTI-PART DETECTION & WORKFLOW (Try all matching archives)
                // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
                
                // SMART SELECTION: Check ALL matching archives for multi-part, pick best one
                console.log(`üîç Checking ${posts.length} matching archive(s) for multi-part content...`);
                let selectedPost = null;
                let selectedManifest = null;
                
                for (let i = 0; i < posts.length; i++) {
                    const manifest = detectManifest(posts[i]);
                    if (manifest && manifest.total_parts > 1) {
                        console.log(`   Archive ${i + 1}: @${posts[i].author}/${posts[i].permlink} - ${manifest.total_parts} parts`);
                        // Use the first multi-part archive found (newest)
                        if (!selectedPost) {
                            selectedPost = posts[i];
                            selectedManifest = manifest;
                            console.log(`   ‚úÖ Selected for multi-part workflow`);
                        }
                    }
                }
                
                // Fallback to first post if no multi-part found
                if (!selectedPost) {
                    selectedPost = posts[0];
                    selectedManifest = detectManifest(selectedPost);
                }
                
                if (selectedManifest && selectedManifest.total_parts > 1) {
                    console.log('üì¶ Multi-part content detected - activating multi-part workflow');
                    console.log(`   Using: @${selectedPost.author}/${selectedPost.permlink}`);
                    
                    // Show multi-part loading UI
                    resultsDiv.innerHTML = `
                        <div class="loading">
                            <div class="spinner"></div>
                            <div style="color: var(--text-muted); margin-top: 1rem;">
                                <h3 style="margin: 0 0 0.5rem 0;">üì¶ Multi-Part Series Detected</h3>
                                <p style="margin: 0 0 1rem 0;">Found ${selectedManifest.total_parts}-part archive. Discovering and fetching all parts...</p>
                                <div id="multipart-progress" style="font-size: 0.9rem; color: var(--text-muted);">
                                    Initializing multi-part discovery...
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Progress callback for user feedback
                    function updateMultiPartProgress(step) {
                        const progressEl = document.getElementById('multipart-progress');
                        if (progressEl) {
                            progressEl.textContent = step;
                        }
                    }
                    
                    try {
                        // TASK 4: Check architecture type to determine fetching strategy
                        const isThreadedArchitecture = selectedManifest.architecture === 'threaded_replies';
                        let seriesParts;
                        
                        if (isThreadedArchitecture) {
                            // NEW: Threaded replies architecture - fetch comment replies
                            console.log('üßµ Threaded replies architecture detected');
                            console.log(`   Root post: @${selectedPost.author}/${selectedPost.permlink}`);
                            
                            updateMultiPartProgress(`üßµ Fetching threaded comment replies...`);
                            
                            // Fetch replies using condenser_api.get_content_replies
                            const threadedPosts = await fetchThreadedReplies(
                                selectedPost.author, 
                                selectedPost.permlink, 
                                selectedManifest.total_parts,
                                (current, total, status) => {
                                    if (status === 'discovering') {
                                        updateMultiPartProgress(`üîç Discovering threaded replies...`);
                                    } else if (status === 'complete') {
                                        updateMultiPartProgress(`‚úÖ Found ${current}/${total} threaded parts`);
                                    } else if (status === 'error') {
                                        updateMultiPartProgress(`‚ùå Failed to fetch threaded replies`);
                                    }
                                }
                            );
                            
                            console.log(`‚úÖ Threaded replies fetched: ${threadedPosts.length}/${selectedManifest.total_parts} parts`);
                            
                            // Transform threaded posts into the format expected by fetchSeriesParts
                            // (same format as findSeriesParts output)
                            seriesParts = threadedPosts.map((post, index) => {
                                const partNumber = index + 1;
                                const postManifest = detectManifest(post);
                                
                                return {
                                    part_number: partNumber,
                                    author: post.author,
                                    permlink: post.permlink,
                                    post_data: post,
                                    manifest: postManifest
                                };
                            });
                            
                            console.log(`‚úÖ Formatted ${seriesParts.length} threaded parts for processing`);
                        } else {
                            // LEGACY: SERIES tag-based architecture (or auto-detect)
                            console.log('üì¶ Checking for SERIES tag-based parts...');
                            
                            updateMultiPartProgress(`üîç Discovering parts using SERIES tag...`);
                            seriesParts = await findSeriesParts(selectedManifest, (found, total, status) => {
                                updateMultiPartProgress(`üîç Discovered ${found}/${total} parts...`);
                            });
                            
                            console.log(`‚úÖ SERIES tag search found ${seriesParts.length}/${selectedManifest.total_parts} parts`);
                            
                            // AUTO-DETECT: If we didn't find all parts, try threaded replies
                            // This handles archives without explicit architecture field
                            if (seriesParts.length < selectedManifest.total_parts) {
                                console.log('üîÑ Missing parts detected - attempting threaded replies fallback...');
                                console.log(`   Missing: ${selectedManifest.total_parts - seriesParts.length} parts`);
                                
                                updateMultiPartProgress(`üßµ Trying threaded replies (auto-detect)...`);
                                
                                try {
                                    const threadedPosts = await fetchThreadedReplies(
                                        selectedPost.author, 
                                        selectedPost.permlink, 
                                        selectedManifest.total_parts,
                                        (current, total, status) => {
                                            if (status === 'discovering') {
                                                updateMultiPartProgress(`üîç Fetching comment replies...`);
                                            } else if (status === 'complete') {
                                                updateMultiPartProgress(`‚úÖ Found ${current}/${total} threaded parts`);
                                            }
                                        }
                                    );
                                    
                                    console.log(`‚úÖ Threaded replies fetched: ${threadedPosts.length}/${selectedManifest.total_parts} parts`);
                                    
                                    // MERGE with SERIES tag results instead of blindly overwriting
                                    if (threadedPosts.length > seriesParts.length) {
                                        console.log('‚úÖ Threaded replies found more parts - merging results...');
                                        console.log(`   Transforming ${threadedPosts.length} raw posts to structured format...`);
                                        
                                        // Transform threaded posts, extracting REAL part numbers from manifest/permlink
                                        const threadedStructured = threadedPosts.map((post) => {
                                            const postManifest = detectManifest(post);
                                            
                                            // Extract REAL part number (don't use index!)
                                            // Priority: manifest.current_part > compact `p` > permlink regex
                                            let partNumber = null;
                                            
                                            if (postManifest) {
                                                partNumber = postManifest.current_part || postManifest.p || null;
                                            }
                                            
                                            // Fallback: Extract from permlink pattern (-part-N)
                                            if (!partNumber && post.permlink) {
                                                const partMatch = post.permlink.match(/-part-(\d+)$/i);
                                                if (partMatch) {
                                                    partNumber = parseInt(partMatch[1], 10);
                                                }
                                            }
                                            
                                            // Validate we got a part number
                                            if (!partNumber) {
                                                console.warn(`‚ö†Ô∏è  Could not extract part number from post:`, post.permlink);
                                                return null; // Skip this post
                                            }
                                            
                                            // Validate post object has required fields
                                            if (!post || !post.author || !post.permlink) {
                                                console.error(`‚ùå Part ${partNumber} missing required fields:`, post);
                                                return null; // Skip this post
                                            }
                                            
                                            return {
                                                part_number: partNumber,
                                                author: post.author,
                                                permlink: post.permlink,
                                                post_data: post,
                                                manifest: postManifest
                                            };
                                        }).filter(item => item !== null); // Remove invalid entries
                                        
                                        console.log(`‚úÖ Transformed ${threadedStructured.length} threaded posts`);
                                        console.log(`   Part numbers: ${threadedStructured.map(p => p.part_number).join(', ')}`);
                                        
                                        // MERGE: Combine SERIES tag results with threaded results
                                        // Create a Map keyed by part_number to avoid duplicates
                                        const partMap = new Map();
                                        
                                        // First add SERIES tag results
                                        seriesParts.forEach(part => {
                                            partMap.set(part.part_number, part);
                                        });
                                        
                                        // Then add/overwrite with threaded results
                                        threadedStructured.forEach(part => {
                                            partMap.set(part.part_number, part);
                                        });
                                        
                                        // Convert back to sorted array
                                        seriesParts = Array.from(partMap.values())
                                            .sort((a, b) => a.part_number - b.part_number);
                                        
                                        console.log(`‚úÖ Merged results: ${seriesParts.length} unique parts`);
                                        console.log(`   Final sequence: ${seriesParts.map(p => p.part_number).join(' ‚Üí ')}`);
                                        
                                        // VALIDATE: Check for contiguous 1..N sequence
                                        const expectedPartNumbers = Array.from({length: selectedManifest.total_parts}, (_, i) => i + 1);
                                        const actualPartNumbers = seriesParts.map(p => p.part_number);
                                        const missingParts = expectedPartNumbers.filter(num => !actualPartNumbers.includes(num));
                                        
                                        if (missingParts.length > 0) {
                                            console.warn(`‚ö†Ô∏è  Merged results still incomplete`);
                                            console.warn(`   Expected: ${expectedPartNumbers.join(', ')}`);
                                            console.warn(`   Found: ${actualPartNumbers.join(', ')}`);
                                            console.warn(`   Missing: ${missingParts.join(', ')}`);
                                            console.warn(`   ‚Üí Continuing anyway (will show as incomplete in UI)`);
                                        } else {
                                            console.log(`‚úÖ All ${selectedManifest.total_parts} parts accounted for - complete series!`);
                                        }
                                    } else {
                                        console.log('‚ö†Ô∏è  Threaded replies found same or fewer parts - keeping SERIES tag results');
                                    }
                                } catch (threadedError) {
                                    console.warn('‚ö†Ô∏è  Threaded replies fallback failed:', threadedError.message);
                                    console.log('   Continuing with SERIES tag results');
                                }
                            }
                        }
                        
                        // Step 2: Fetch all parts in parallel
                        updateMultiPartProgress(`üì• Fetching ${seriesParts.length} parts in parallel...`);
                        const fetchResult = await fetchSeriesParts(seriesParts, selectedManifest.total_parts, (partNum, total, status) => {
                            if (status === 'fetching') {
                                updateMultiPartProgress(`üì• Fetching part ${partNum}/${total}...`);
                            } else if (status === 'success') {
                                updateMultiPartProgress(`‚úÖ Part ${partNum}/${total} fetched successfully`);
                            } else if (status === 'error') {
                                updateMultiPartProgress(`‚ùå Part ${partNum}/${total} failed to fetch`);
                            }
                        });
                        
                        // Step 3: Reassemble and verify content
                        updateMultiPartProgress(`üîó Reassembling and verifying content...`);
                        const reassemblyResult = await reassembleContent(fetchResult.parts, selectedManifest);
                        
                        console.log(`‚úÖ Content reassembly complete. Verified: ${reassemblyResult.verified}`);
                        
                        // Store full content for modal
                        _fullContentCache = reassemblyResult.reassembled || '';
                        
                        // Step 4: Display multi-part UI
                        const sourceUrl = selectedManifest.source_url || url;
                        const multiPartHTML = generateMultiPartUI(
                            selectedManifest,
                            fetchResult.parts,
                            reassemblyResult,
                            sourceUrl,
                            searchMethod
                        );
                        
                        resultsDiv.innerHTML = multiPartHTML;
                        
                        // Multi-part workflow complete - skip single-part forEach loop
                        console.log('‚úÖ Multi-part workflow complete');
                        return;
                        
                    } catch (error) {
                        console.error('‚ùå Multi-part workflow failed:', error);
                        
                        // Show error and fall back to single-part display
                        resultsDiv.innerHTML = `
                            <div class="error-message">
                                <h3 style="margin: 0 0 1rem 0;">‚ùå Multi-Part Processing Failed</h3>
                                <p style="margin: 0 0 1rem 0;"><strong>${error.message}</strong></p>
                                <p style="margin: 0;">Falling back to single-part view...</p>
                            </div>
                        `;
                        
                        // Continue to single-part display after 2 seconds
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }
                
                // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
                // SINGLE-PART VERIFICATION (Backward Compatibility)
                // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
                
                console.log('‚úÖ No multi-part manifest detected - using single-part verification');
                
                // Display results with verification
                let html_output = `<div class="success-icon">‚úÖ</div>
                    <h2 class="result-title">Found ${posts.length} Archived ${posts.length === 1 ? 'Copy' : 'Copies'}</h2>
                    <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.2); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; font-size: 0.9rem;">
                        <strong>üîç Search method:</strong> ${searchMethod}<br>
                        ${html ? `<strong>üè∑Ô∏è Smart tags used:</strong> ${tags.slice(0, 5).join(', ')}<br>` : ''}
                        <strong>üìä Searched:</strong> ${allPosts.length} total archives, matched ${posts.length}
                        ${posts.length > 1 ? `<br><strong>üìö Version History:</strong> ${posts.length} versions found (showing chronological order)` : ''}
                    </div>`;
                
                posts.forEach((post, i) => {
                    // Determine version label
                    let versionLabel = '';
                    let versionBadgeColor = '';
                    if (posts.length > 1) {
                        if (i === 0) {
                            versionLabel = 'Original';
                            versionBadgeColor = '#3b82f6'; // Blue
                        } else {
                            versionLabel = `Edited v${i}`;
                            versionBadgeColor = '#f59e0b'; // Amber
                        }
                    }
                    // Parse metadata
                    let metadata = post.json_metadata;
                    if (typeof metadata === 'string') {
                        try {
                            metadata = JSON.parse(metadata);
                        } catch (e) {
                            metadata = {};
                        }
                    }
                    metadata = metadata || {};
                    
                    const hiveUrl = `https://ecency.com/@${post.author}/${post.permlink}`;
                    const date = new Date(post.created).toLocaleDateString();
                    const sourceUrl = metadata.sourceUrl || url;
                    
                    // Extract hashes from post body
                    const sha256Match = post.body.match(/SHA-256:\s*`?([a-f0-9]{64})`?/i);
                    const blake2bMatch = post.body.match(/BLAKE2b:\s*`?([a-f0-9]{64})`?/i);
                    const md5Match = post.body.match(/MD5:\s*`?([a-f0-9]{32})`?/i);
                    
                    const archivedHashes = {
                        sha256: sha256Match ? sha256Match[1] : null,
                        blake2b: blake2bMatch ? blake2bMatch[1] : null,
                        md5: md5Match ? md5Match[1] : null
                    };
                    
                    // Compare hashes if current content provided
                    let verificationHtml = '';
                    if (currentHashes && archivedHashes.sha256) {
                        const sha256Matches = currentHashes.sha256 === archivedHashes.sha256;
                        const blake2bMatches = currentHashes.blake2b === archivedHashes.blake2b;
                        const md5Matches = currentHashes.md5 === archivedHashes.md5;
                        
                        if (sha256Matches && blake2bMatches && md5Matches) {
                            verificationHtml = `
                                <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 1.25rem; border-radius: 8px; margin-bottom: 1.5rem;">
                                    <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 0.5rem;">‚úÖ CONTENT VERIFIED - EXACT MATCH</div>
                                    <div style="font-size: 0.95rem; opacity: 0.95;">All cryptographic hashes match perfectly. Content is identical to the archived version from ${date}.</div>
                                </div>
                            `;
                        } else {
                            verificationHtml = `
                                <div style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; padding: 1.25rem; border-radius: 8px; margin-bottom: 1.5rem;">
                                    <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 0.5rem;">‚ö†Ô∏è CONTENT CHANGED</div>
                                    <div style="font-size: 0.95rem; opacity: 0.95; margin-bottom: 0.75rem;">The current page content differs from the archived version. This could mean:</div>
                                    <ul style="margin: 0; padding-left: 1.5rem; font-size: 0.9rem; opacity: 0.9;">
                                        <li>The page was legitimately edited or updated</li>
                                        <li>The content was tampered with or modified</li>
                                    </ul>
                                    <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.3); font-size: 0.85rem;">
                                        <strong>Hash verification:</strong> SHA-256: ${sha256Matches ? '‚úì' : '‚úó'} | BLAKE2b: ${blake2bMatches ? '‚úì' : '‚úó'} | MD5: ${md5Matches ? '‚úì' : '‚úó'}
                                    </div>
                                    <div style="margin-top: 1rem;">
                                        <a href="archive-paste.html?url=${encodeURIComponent(sourceUrl)}" 
                                           style="display: inline-block; background: rgba(255,255,255,0.95); color: #d97706; padding: 0.75rem 1.5rem; border-radius: 8px; text-decoration: none; font-weight: 700; border: 2px solid rgba(255,255,255,0.3); transition: all 0.2s;"
                                           onmouseover="this.style.background='white'; this.style.transform='translateY(-2px)'"
                                           onmouseout="this.style.background='rgba(255,255,255,0.95)'; this.style.transform='translateY(0)'">
                                            üìù Archive New Version ‚Üí
                                        </a>
                                    </div>
                                </div>
                            `;
                        }
                    }
                    
                    html_output += `
                        <div class="result-section" style="background: var(--primary-bg); border: 2px solid var(--border); border-radius: 12px; padding: 0; margin-bottom: 1.5rem; overflow: hidden;">
                            <!-- Header with blockchain link -->
                            <div style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); padding: 1.25rem; color: white;">
                                <div style="display: flex; align-items: center; justify-content: space-between; gap: 1rem; flex-wrap: wrap;">
                                    <div style="flex: 1; min-width: 200px;">
                                        <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                            <div style="font-size: 0.85rem; opacity: 0.9;">Archived ${date}</div>
                                            ${versionLabel ? `<span style="background: ${versionBadgeColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;">${versionLabel}</span>` : ''}
                                        </div>
                                        <div style="font-weight: 700; font-size: 1.1rem;">${escapeHtml(post.title)}</div>
                                    </div>
                                    <a href="${hiveUrl}" target="_blank" style="background: rgba(255,255,255,0.2); color: white; padding: 0.75rem 1.25rem; border-radius: 8px; text-decoration: none; font-weight: 600; white-space: nowrap; transition: all 0.2s; border: 1px solid rgba(255,255,255,0.3);" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                                        üîó View on Hive Blockchain ‚Üí
                                    </a>
                                </div>
                            </div>
                            
                            <div style="padding: 1.5rem;">
                                <!-- Source URL -->
                                <div style="background: var(--secondary-bg); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                                    <div style="font-weight: 600; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.5px;">üìç Archived URL</div>
                                    <div style="font-family: 'Monaco', 'Courier New', monospace; font-size: 0.9rem; color: var(--accent); word-break: break-all;">
                                        <a href="${escapeHtml(sourceUrl)}" target="_blank" style="color: #3b82f6; text-decoration: none;">${escapeHtml(sourceUrl)}</a>
                                    </div>
                                </div>
                                
                                ${metadata.provenance && metadata.provenance.source_type === 'wikipedia' && metadata.provenance.revision_id ? `
                                <!-- Source Provenance (Wikipedia) -->
                                <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(109, 40, 217, 0.1) 100%); border: 2px solid rgba(139, 92, 246, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                                    <div style="font-weight: 600; font-size: 0.95rem; color: #7c3aed; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                                        <span>üîê</span>
                                        <span>Source Provenance (Authenticity Proof)</span>
                                    </div>
                                    <div style="display: grid; gap: 0.5rem; font-size: 0.9rem;">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <span style="color: var(--text-muted);">üìö Source Type:</span>
                                            <span style="color: var(--text); font-weight: 600;">Wikipedia</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <span style="color: var(--text-muted);">üî¢ Revision ID:</span>
                                            <a href="${metadata.provenance.permanent_url}" target="_blank" style="color: #3b82f6; font-weight: 600; text-decoration: none;">
                                                ${metadata.provenance.revision_id} ‚Üó
                                            </a>
                                        </div>
                                        ${metadata.provenance.page_id ? `
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <span style="color: var(--text-muted);">üìÑ Page ID:</span>
                                            <span style="color: var(--text);">${metadata.provenance.page_id}</span>
                                        </div>
                                        ` : ''}
                                        ${metadata.provenance.api_timestamp ? `
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <span style="color: var(--text-muted);">‚è±Ô∏è Captured:</span>
                                            <span style="color: var(--text);">${new Date(metadata.provenance.api_timestamp).toLocaleString()}</span>
                                        </div>
                                        ` : ''}
                                    </div>
                                    <div style="margin-top: 0.75rem; padding: 0.5rem 0.75rem; background: rgba(139, 92, 246, 0.1); border-radius: 6px;">
                                        <p style="font-size: 0.8rem; color: #7c3aed; margin: 0; line-height: 1.4;">
                                            <strong>‚úì Verified Source:</strong> Click the revision ID to verify the original Wikipedia content.
                                        </p>
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${metadata.archiveVersion ? `
                                <!-- Version Update Info -->
                                <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(217, 119, 6, 0.1) 100%); border: 2px solid rgba(245, 158, 11, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                                    <div style="font-weight: 600; font-size: 0.95rem; color: #d97706; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                                        <span>üìù</span>
                                        <span>Version Update (Edit History)</span>
                                    </div>
                                    <div style="display: grid; gap: 0.5rem; font-size: 0.9rem;">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <span style="color: var(--text-muted);">Version:</span>
                                            <span style="color: #d97706; font-weight: 700;">#${metadata.archiveVersion.version || metadata.archiveVersion}</span>
                                        </div>
                                        ${metadata.archiveVersion.similarity !== undefined ? `
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <span style="color: var(--text-muted);">Similarity:</span>
                                            <span style="color: ${metadata.archiveVersion.similarity >= 90 ? '#10b981' : metadata.archiveVersion.similarity >= 70 ? '#f59e0b' : '#ef4444'}; font-weight: 600;">${metadata.archiveVersion.similarity}%</span>
                                        </div>
                                        ` : ''}
                                        ${metadata.archiveVersion.originalAuthor && metadata.archiveVersion.originalPermlink ? `
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <span style="color: var(--text-muted);">Original:</span>
                                            <a href="https://ecency.com/@${metadata.archiveVersion.originalAuthor}/${metadata.archiveVersion.originalPermlink}" target="_blank" style="color: #3b82f6; text-decoration: none; font-weight: 600;">
                                                @${metadata.archiveVersion.originalAuthor} ‚Üó
                                            </a>
                                        </div>
                                        ` : ''}
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${verificationHtml}
                                
                                <!-- Cryptographic Hashes -->
                                <div style="background: var(--secondary-bg); border: 1px solid var(--border); border-radius: 8px; padding: 1.25rem;">
                                    <div style="font-weight: 600; font-size: 0.95rem; color: var(--text); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                                        <span>üîê</span>
                                        <span>Cryptographic Fingerprint (Content Hashes)</span>
                                    </div>
                                    <div style="font-family: 'Monaco', 'Courier New', monospace; font-size: 0.8rem; line-height: 1.8; color: var(--text-muted);">
                                        ${archivedHashes.sha256 ? `
                                            <div style="margin-bottom: 0.75rem;">
                                                <div style="color: var(--text); font-weight: 600; margin-bottom: 0.25rem;">SHA-256:</div>
                                                <div style="word-break: break-all; background: var(--primary-bg); padding: 0.5rem; border-radius: 4px; border: 1px solid var(--border);">${archivedHashes.sha256}</div>
                                            </div>
                                        ` : ''}
                                        ${archivedHashes.blake2b ? `
                                            <div style="margin-bottom: 0.75rem;">
                                                <div style="color: var(--text); font-weight: 600; margin-bottom: 0.25rem;">BLAKE2b:</div>
                                                <div style="word-break: break-all; background: var(--primary-bg); padding: 0.5rem; border-radius: 4px; border: 1px solid var(--border);">${archivedHashes.blake2b}</div>
                                            </div>
                                        ` : ''}
                                        ${archivedHashes.md5 ? `
                                            <div>
                                                <div style="color: var(--text); font-weight: 600; margin-bottom: 0.25rem;">MD5:</div>
                                                <div style="word-break: break-all; background: var(--primary-bg); padding: 0.5rem; border-radius: 4px; border: 1px solid var(--border);">${archivedHashes.md5}</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                                
                                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border); font-size: 0.85rem; color: var(--text-muted);">
                                    <strong>Archived by:</strong> @${escapeHtml(post.author)} ‚Ä¢ <strong>Posted:</strong> ${date}
                                </div>
                                
                                <!-- View on Chain link - opens full blockchain post -->
                                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                                    <a href="${hiveUrl}" 
                                       target="_blank"
                                       style="display: block; width: 100%; padding: 0.875rem 1.5rem; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 1rem; transition: transform 0.2s, box-shadow 0.2s; text-decoration: none; text-align: center; box-sizing: border-box;"
                                       onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 10px 25px rgba(16, 185, 129, 0.3)'"
                                       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                        üîó View on Chain
                                    </a>
                                    <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted); text-align: center;">
                                        View the full archived post on the Hive blockchain
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                resultsDiv.innerHTML = html_output;
                
            } catch (error) {
                console.error('‚ùå Search error:', error);
                
                // Check if user cancelled the search
                if (error.message.includes('cancelled by user')) {
                    console.log('üõë User cancelled the search');
                    resultsDiv.classList.remove('show');
                    return;
                }
                
                resultsDiv.innerHTML = `
                    <div class="error-message">
                        <h3 style="margin: 0 0 1rem 0;">‚ùå Search Failed</h3>
                        <p style="margin: 0 0 1rem 0;"><strong>${error.message}</strong></p>
                        <p style="margin: 0 0 1rem 0;">We tried ${window.ArcHiveHiveLookup.HIVE_API_NODES.length} different Hive API nodes, but all failed to respond.</p>
                        <button onclick="processInput()" style="margin-bottom: 1rem; padding: 0.75rem 1.5rem; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            üîÑ Retry Search
                        </button>
                        <p style="margin: 0 0 1rem 0;"><strong>Possible causes:</strong></p>
                        <ul style="margin: 0 0 1rem 1.5rem; text-align: left;">
                            <li>Your internet connection may be unstable</li>
                            <li>Hive API nodes may be experiencing temporary downtime</li>
                            <li>Browser may be blocking API requests (check console)</li>
                        </ul>
                        <p style="margin: 0;"><strong>Try again in a few moments.</strong> If the problem persists, check <a href="https://hive-status.com" target="_blank" style="color: #3b82f6;">Hive API status</a>.</p>
                    </div>
                `;
            }
        }
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Stub cache functions for compatibility with existing UI buttons
        function viewCacheStats() {
            document.getElementById('results').innerHTML = `
                <div class="error-message">
                    <h3 style="margin: 0 0 1rem 0;">‚ÑπÔ∏è Cache Not Available</h3>
                    <p style="margin: 0;">Link Explorer uses direct blockchain search. No local cache is maintained.</p>
                </div>
            `;
            document.getElementById('results').classList.add('show');
        }
        
        function clearCacheConfirm() {
            document.getElementById('results').innerHTML = `
                <div class="error-message">
                    <h3 style="margin: 0 0 1rem 0;">‚ÑπÔ∏è No Cache to Clear</h3>
                    <p style="margin: 0;">Link Explorer searches the blockchain directly without local caching.</p>
                </div>
            `;
            document.getElementById('results').classList.add('show');
        }
        
        // Main entry point
        function processInput() {
            searchHash();
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            console.log('‚úÖ Link Explorer initialized');
            
            const urlInput = document.getElementById('urlInput');
            const searchBtn = document.querySelector('button[type="submit"]');
            
            if (searchBtn) {
                searchBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    searchHash();
                });
            }
            
            if (urlInput) {
                urlInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        searchHash();
                    }
                });
            }
        });
        
        // Expose necessary functions to global scope for onclick handlers
        window.processInput = processInput;
        window.viewCacheStats = viewCacheStats;
        window.clearCacheConfirm = clearCacheConfirm;
        window.showUnifiedView = showUnifiedView;
        window.showIndividualView = showIndividualView;
        window.escapeHtml = escapeHtml;
        window.openFullContentModal = openFullContentModal;
        window.closeFullContentModal = closeFullContentModal;
        
        console.log('‚úÖ Link Explorer functions exposed to global scope:', 
                    Object.keys({processInput, viewCacheStats, clearCacheConfirm, showUnifiedView, showIndividualView, escapeHtml, openFullContentModal, closeFullContentModal}));
        
        })(); // End IIFE
    </script>
</body>
</html>
